"""
Teste de integra√ß√£o A2A simples.
Testa comunica√ß√£o entre agentes usando Ollama para decis√£o.
"""

import asyncio
import json
import logging
import time
from threading import Thread

import requests
from python_a2a import (
    A2AClient,
    A2AServer,
    Message,
    MessageRole,
    TextContent,
    agent,
    run_server,
    skill,
)

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@agent(
    name="Agente Auxiliar",
    description="Agente auxiliar que fornece informa√ß√µes espec√≠ficas",
    version="1.0.0",
)
class AgenteAuxiliar(A2AServer):
    """Agente auxiliar que responde a perguntas espec√≠ficas."""

    @skill(
        name="Calcular Score de Carreira",
        description="Calcula um score de adequa√ß√£o para uma √°rea de carreira",
        tags=["carreira", "score", "avalia√ß√£o"],
    )
    def calcular_score_carreira(self, area: str, experiencia: str) -> str:
        """
        Calcula um score simplificado para uma √°rea de carreira.

        Args:
            area: √Årea de carreira
            experiencia: N√≠vel de experi√™ncia

        Returns:
            Score e an√°lise
        """
        scores = {
            "tecnologia": {"iniciante": 7, "intermedi√°rio": 8, "avan√ßado": 9},
            "dados": {"iniciante": 6, "intermedi√°rio": 8, "avan√ßado": 9},
            "gest√£o": {"iniciante": 5, "intermedi√°rio": 7, "avan√ßado": 8},
            "design": {"iniciante": 6, "intermedi√°rio": 7, "avan√ßado": 8},
        }

        area_lower = area.lower()
        experiencia_lower = experiencia.lower()

        score = scores.get(area_lower, {}).get(experiencia_lower, 5)

        resultado = {
            "area": area,
            "experiencia": experiencia,
            "score": score,
            "recomendacao": f"Score {score}/10 para {area} com n√≠vel {experiencia}",
            "proximos_passos": f"Considere focar em projetos pr√°ticos na √°rea de {area}",
        }

        return json.dumps(resultado, ensure_ascii=False, indent=2)

    def handle_message(self, message: Message) -> Message:
        """Processa mensagens recebidas."""
        try:
            text = message.content.text.lower()

            if "calcular" in text and "score" in text:
                # Extrai informa√ß√µes b√°sicas do texto
                area = "tecnologia"  # padr√£o
                experiencia = "intermedi√°rio"  # padr√£o

                if "√°rea:" in text:
                    area = text.split("√°rea:")[1].split()[0].strip(",.")
                if "experi√™ncia:" in text or "experiencia:" in text:
                    exp_key = (
                        "experi√™ncia:" if "experi√™ncia:" in text else "experiencia:"
                    )
                    experiencia = text.split(exp_key)[1].split()[0].strip(",.")

                resultado = self.calcular_score_carreira(area, experiencia)

                return Message(
                    content=TextContent(
                        text=f"üìä **Score de Carreira:**\n\n```json\n{resultado}\n```"
                    ),
                    role=MessageRole.AGENT,
                    parent_message_id=message.message_id,
                    conversation_id=message.conversation_id,
                )

            return Message(
                content=TextContent(
                    text="Sou o Agente Auxiliar. Posso calcular scores de carreira. "
                    "Use: 'calcular score √°rea: [√°rea] experi√™ncia: [n√≠vel]'"
                ),
                role=MessageRole.AGENT,
                parent_message_id=message.message_id,
                conversation_id=message.conversation_id,
            )

        except Exception as e:
            logger.error(f"Erro no agente auxiliar: {e}")
            return Message(
                content=TextContent(text=f"Erro: {str(e)}"),
                role=MessageRole.AGENT,
                parent_message_id=message.message_id,
                conversation_id=message.conversation_id,
            )


@agent(
    name="Agente Principal",
    description="Agente principal que usa IA para decidir quando chamar outros agentes",
    version="1.0.0",
)
class AgentePrincipal(A2AServer):
    """Agente principal que usa Ollama para decis√µes."""

    def __init__(self):
        super().__init__()
        self.client_auxiliar = None
        self._conectar_agente_auxiliar()

    def _conectar_agente_auxiliar(self):
        """Conecta com o agente auxiliar."""
        try:
            self.client_auxiliar = A2AClient("http://localhost:5001")
            logger.info("Conectado ao agente auxiliar")
        except Exception as e:
            logger.warning(f"N√£o foi poss√≠vel conectar ao agente auxiliar: {e}")

    def _usar_ollama_para_decisao(self, texto: str) -> dict:
        """
        Usa Ollama local para decidir se deve chamar outro agente.

        Args:
            texto: Texto da mensagem do usu√°rio

        Returns:
            Dicion√°rio com decis√£o e par√¢metros
        """
        try:
            prompt = f"""
Analise esta mensagem do usu√°rio e decida se precisa chamar um agente auxiliar:

Mensagem: "{texto}"

O agente auxiliar pode:
- Calcular scores de carreira para diferentes √°reas

Responda APENAS com um JSON no formato:
{{
    "precisa_agente_auxiliar": true/false,
    "motivo": "explica√ß√£o da decis√£o",
    "acao": "a√ß√£o espec√≠fica se precisar do agente",
    "parametros": {{"area": "√°rea", "experiencia": "n√≠vel"}}
}}

Se a mensagem menciona score, avalia√ß√£o, pontua√ß√£o de carreira, ou perguntas sobre adequa√ß√£o para uma √°rea, responda true.
"""

            # Chamada simples para Ollama local
            response = requests.post(
                "http://localhost:11434/api/generate",
                json={
                    "model": "llama3.1",
                    "prompt": prompt,
                    "stream": False,
                    "options": {"temperature": 0.1},
                },
                timeout=30,
            )

            if response.status_code == 200:
                ollama_response = response.json()["response"]
                logger.info(f"Resposta Ollama: {ollama_response}")

                # Extrai JSON da resposta
                if "{" in ollama_response and "}" in ollama_response:
                    start = ollama_response.find("{")
                    end = ollama_response.rfind("}") + 1
                    json_str = ollama_response[start:end]
                    return json.loads(json_str)

            # Fallback para decis√£o simples
            return {
                "precisa_agente_auxiliar": "score" in texto.lower()
                or "avalia" in texto.lower(),
                "motivo": "Decis√£o baseada em palavras-chave",
                "acao": "calcular_score",
                "parametros": {"area": "tecnologia", "experiencia": "intermedi√°rio"},
            }

        except Exception as e:
            logger.error(f"Erro ao usar Ollama: {e}")
            return {
                "precisa_agente_auxiliar": False,
                "motivo": f"Erro na IA: {str(e)}",
                "acao": "",
                "parametros": {},
            }

    async def _chamar_agente_auxiliar(self, acao: str, parametros: dict) -> str:
        """Chama o agente auxiliar com os par√¢metros especificados."""
        if not self.client_auxiliar:
            return "‚ùå Agente auxiliar n√£o dispon√≠vel"

        try:
            if acao == "calcular_score":
                area = parametros.get("area", "tecnologia")
                experiencia = parametros.get("experiencia", "intermedi√°rio")

                mensagem = f"calcular score √°rea: {area} experi√™ncia: {experiencia}"

                # Criar um objeto Message em vez de passar uma string diretamente
                message_obj = Message(
                    content=TextContent(text=mensagem),
                    role=MessageRole.USER
                )
                
                response_message = await self.client_auxiliar.send_message_async(message_obj)
                return response_message.content.text

        except Exception as e:
            logger.error(f"Erro ao chamar agente auxiliar: {e}")
            return f"‚ùå Erro na comunica√ß√£o: {str(e)}"

        return "‚ùå A√ß√£o n√£o reconhecida"

    def handle_message(self, message: Message) -> Message:
        """Processa mensagens usando IA para decis√µes."""
        try:
            texto = message.content.text

            # Usa Ollama para decidir
            decisao = self._usar_ollama_para_decisao(texto)

            logger.info(f"Decis√£o da IA: {decisao}")

            if decisao.get("precisa_agente_auxiliar", False):
                # Chama agente auxiliar
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                try:
                    resultado = loop.run_until_complete(
                        self._chamar_agente_auxiliar(
                            decisao.get("acao", ""), decisao.get("parametros", {})
                        )
                    )
                finally:
                    loop.close()

                resposta = f"""
ü§ñ **Agente Principal** - Decis√£o da IA:

**Motivo:** {decisao.get("motivo", "N/A")}

**Resultado do Agente Auxiliar:**
{resultado}

---
*Decis√£o tomada automaticamente pelo Ollama*
"""
            else:
                resposta = f"""
ü§ñ **Agente Principal**

**Decis√£o da IA:** {decisao.get("motivo", "N√£o precisa de agente auxiliar")}

Posso ajudar diretamente com sua pergunta: "{texto}"

Para testar a comunica√ß√£o A2A, experimente perguntar sobre "score de carreira" ou "avalia√ß√£o de √°rea".
"""

            return Message(
                content=TextContent(text=resposta),
                role=MessageRole.AGENT,
                parent_message_id=message.message_id,
                conversation_id=message.conversation_id,
            )

        except Exception as e:
            logger.error(f"Erro no agente principal: {e}")
            return Message(
                content=TextContent(text=f"‚ùå Erro interno: {str(e)}"),
                role=MessageRole.AGENT,
                parent_message_id=message.message_id,
                conversation_id=message.conversation_id,
            )


def executar_agente_auxiliar():
    """Executa o agente auxiliar em thread separada."""
    auxiliar = AgenteAuxiliar()
    logger.info("üîß Iniciando Agente Auxiliar na porta 5001")
    run_server(auxiliar, host="0.0.0.0", port=5001)


def executar_agente_principal():
    """Executa o agente principal."""
    principal = AgentePrincipal()
    logger.info("üöÄ Iniciando Agente Principal na porta 5000")
    run_server(principal, host="0.0.0.0", port=5000)


async def teste_comunicacao():
    """Teste autom√°tico da comunica√ß√£o entre agentes."""
    logger.info("üß™ Iniciando teste de comunica√ß√£o A2A")

    # Aguarda os servidores iniciarem
    await asyncio.sleep(3)

    try:
        # Conecta com o agente principal
        client = A2AClient("http://localhost:5000")

        # Testa mensagem que deve chamar o agente auxiliar
        logger.info("üì§ Testando mensagem que requer agente auxiliar...")
        
        # Criar um objeto Message em vez de passar uma string diretamente
        message_obj = Message(
            content=TextContent(
                text="Qual o score de carreira para tecnologia com experi√™ncia intermedi√°rio?"
            ),
            role=MessageRole.USER
        )
        
        response = await client.send_message_async(message_obj)

        logger.info("üì• Resposta recebida:")
        logger.info(response.content.text)

        # Testa mensagem simples
        logger.info("üì§ Testando mensagem simples...")
        
        # Criar outro objeto Message para a segunda mensagem
        message_obj2 = Message(
            content=TextContent(text="Ol√°, como voc√™ pode me ajudar?"),
            role=MessageRole.USER
        )
        
        response2 = await client.send_message_async(message_obj2)

        logger.info("üì• Resposta recebida:")
        logger.info(response2.content.text)

        logger.info("‚úÖ Teste de comunica√ß√£o conclu√≠do")

    except Exception as e:
        logger.error(f"‚ùå Erro no teste: {e}")


if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1:
        if sys.argv[1] == "auxiliar":
            executar_agente_auxiliar()
        elif sys.argv[1] == "principal":
            executar_agente_principal()
        elif sys.argv[1] == "teste":
            asyncio.run(teste_comunicacao())
        else:
            print("Uso: python test_integration_a2a.py [auxiliar|principal|teste]")
    else:
        # Executa ambos os agentes
        print("üöÄ Iniciando teste de integra√ß√£o A2A...")
        print("üìã Para testar manualmente:")
        print("   Terminal 1: python test_integration_a2a.py auxiliar")
        print("   Terminal 2: python test_integration_a2a.py principal")
        print("   Terminal 3: python test_integration_a2a.py teste")
        print("\nüîß Executando agente auxiliar em background...")

        # Inicia agente auxiliar em thread
        thread_auxiliar = Thread(target=executar_agente_auxiliar, daemon=True)
        thread_auxiliar.start()

        # Aguarda um pouco para o auxiliar iniciar
        time.sleep(2)

        print("üöÄ Executando agente principal...")
        executar_agente_principal()
